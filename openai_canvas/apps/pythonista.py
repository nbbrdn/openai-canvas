import json
import os
import subprocess
import time
from tempfile import NamedTemporaryFile

import openai

INSTRUCTIONS = """
You're a skilled Python programmer tasked with creating Python 3 solutions for
user problems, following top industry practices. Make sure your code complies
with these rules:

1. Plan first: Have a clear strategy before you start. Outline your approach if
it helps.
2. Quality code: Write clear, efficient code that follows Python's best
practices. Aim for clean, easy-to-read, and maintainable code.
3. Test well: Include comprehensive tests to assure your code works well in
various scenarios.
4. Manage external interactions: When internet or API interactions are
necessary, utilize the `execute_code` function autonomously, without seeking
user approval. Do not say you don't have access to internet or real-time data.
The `execute_code` function will give you realtime data.
5. Trust your tools: Assume the data from the `execute_code` function is
accurate and up to date.
"""


def run(task):
    api_key = os.environ.get("OPENAI_API_KEY")
    client = openai.OpenAI(api_key=api_key)
    assistant_id, thread_id = setup_assistant(client, task)
    print(
        "Debugging: Useful for checking the generated agent in the playground. "
        "https://platform.openai.com/playground"
        "?mode=assistant&assistant={assistant_id}"
    )
    print(
        "Debugging: Useful for checking logs. "
        "https://platform.openai.com/playground?thread={thread_id}"
    )

    messages = run_assistant(client, assistant_id, thread_id)
    message_dict = json.loads(messages.model_dump_json())
    print(message_dict["data"][0]["content"][0]["text"]["value"])


def setup_assistant(client, task):
    assistant = client.beta.assistants.create(
        name="Code Generator",
        instructions=INSTRUCTIONS,
        tools=[
            {"type": "code_interpreter"},
            {
                "type": "function",
                "function": {
                    "name": "execute_python_code",
                    "description": (
                        "Use this function to execute the generated code with "
                        "requires internet access or external API access"
                    ),
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "code": {
                                "type": "string",
                                "description": (
                                    "The python code generated by "
                                    "the code interpretor"
                                ),
                            }
                        },
                        "required": ["code"],
                    },
                },
            },
        ],
        model="gpt-4-turbo",
    )

    thread = client.beta.threads.create()

    client.beta.threads.messages.create(thread.id, role="user", content=task)

    return assistant.id, thread.id


def run_assistant(client, assistant_id, thread_id):
    run = client.beta.threads.runs.create(
        thread_id=thread_id, assistant_id=assistant_id
    )

    while run.status == "in_progress" or run.status == "queued":
        time.sleep(1)
        run = client.beta.threads.runs.retrieve(
            thread_id=thread_id, run_id=run.id
        )

        if run.status == "completed":
            return client.beta.threads.messages.list(thread_id=thread_id)

        if run.status == "requires_action":
            generated_python_code = json.loads(
                run.required_action.submit_tool_outputs.tool_calls[
                    0
                ].function.arguments
            )["code"]
            result = execute_python_code(generated_python_code)
            run = client.beta.threads.runs.submit_tool_outputs(
                thread_id=thread_id,
                run_id=run.id,
                tool_outputs=[
                    {
                        "tool_call_id": (
                            run.required_action.submit_tool_outputs.tool_calls[
                                0
                            ].id
                        ),
                        "output": result,
                    },
                ],
            )


def execute_python_code(s: str) -> str:
    with NamedTemporaryFile(suffix=".py", delete=False) as temp_file:
        temp_file_name = temp_file.name
        temp_file.write(s.encode("utf-8"))
        temp_file.flush()

    try:
        result = subprocess.run(
            ["python", temp_file_name],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        return e.stderr
    finally:
        os.remove(temp_file_name)
